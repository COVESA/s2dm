var relearn_search_index = [
  {
    "breadcrumb": "S2DM",
    "content": "Simplified Semantic Data Modeling (S2DM) - Approach Primer Table of Contents Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Vehicle Signal Specification has been an alternative but requires improvements Design principles Problem Requirements Goal Artifact Proposed solution approach General workflow Idea (1): Maintain Entity and Property sets Idea (2): Maintain a set of reusable labels Idea (3): Construct unique IDs Idea (4): Allow arbitrary hierarchies for different classification criteria Other ideas Examples Special considerations Special cross references Model versioning Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Subject Matter Experts (SMEs) are often not familiar with data modeling, nor are they following best practices to formalize their knowledge. This lack in expertise can be problematic when they are in charge of expanding and maintaining a certain controlled vocabulary that will be used in real systems at the enterprise level.\nVehicle Signal Specification has been an alternative but requires improvements When it comes to vehicle data, the Vehicle Signal Specification (VSS) has been offering an easy-to-follow approach to enable SMEs contribute to a controlled vocabulary of high-level vehicle properties (e.g., Speed, Acceleration, etc.).\nVehicle Signal Specification (VSS) is a controlled vocabulary for the properties of a car organized in a hierarchical tree. To learn more about VSS, please visit the official documentation page.\nThe VSS modeling approach has been well received by SMEs who have been extending the list of properties both publicly at the COVESA alliance and internally at BMW. However, this approach has reached its limits on what one can express with it. Among the limitations, is the fact that VSS uses a custom file extension .vspec that referes to files written in YAML with a custom syntax. The language used in vspec, as of December 2024, does not support cross references. Thus, it is not possible to model multiple inter-connected domains.\nIf you want to learn more about the current limitations of VSS, please visit these resources:\nDefining the COVESA data modeling strategy and its associated artifacts Towards a Vehicle DATA specification Vehicle DATA Specification The reference mapping between the Vehicle Signal Specification (VSS) and this S2DM approach is documeted in /docs/s2dm_vss_mapping.md.\nDesign principles Problem Disparate vehicle data models that lack proper semantics. Requirements Criteria Requirement Simplicity Modeling approach is easy to follow. Its representation is not verbose. It is friendly for anyone new to the area. It is easy to add new concepts. Technology agnosticism Data model can be used with any downstream technology (e.g., by exporting it into multiple schemas). Modularity Data model can be split into multiple (reusable) small pieces. Scalability \u0026 Maintainability Model can scale up (e.g., concepts are extended). It can be easily maintained (e.g., changes and extensions are possible). Metadata resource uniqueness Concepts in the data model are uniquely identifiable with future-proof ids (e.g., by the use of International Resource Identifiers (IRIs)). Support for multiple classification schemes Polyhierarchies are supported to classify the terms in the vocabulary with different classification criteria (i.e., useful for data catalogs). Support for cross-domain references Multiple cross-referenced domains are supported natively by the language (useful for contextual data). Community \u0026 Tools Data model can be used in multiple up-to-date public tools. Modeling approach is based on a language that is already established in the open community. Goal To minimize the effort needed to develop, extend, and maintain vehicle-related semantic data models. Artifact A guideline on how to model vehicle-related data with proper semantics and good practices. Proposed solution approach General workflow A simplified approach (see figure’s left side) could be the adequate bridge between the ideal enterprise metadata management and the actual use of a domain data model in an application. Specially in cases where SMEs are actively extending a set of data structures that are needed in practice. Also, when alliances or consortiums consist of multiple external stakeholders.\nOverall, a SME should be able to intuitively search and find the data of interest via a data catalog. If the desired data is found, tools must allow the export of it into the structure needed in the application. In the case that no existing data matches his needs, simple steps must allow the modeling of the missing concepts. To that end, such a process is proposed with the following ideas:\nIdea (1): Maintain Entity and Property sets In an application, most of the value is centered around what one can read or write. Thus, the most granular structure corresponds always to a certain Property (aka., characteristic, attribute, etc.). For example: the position of the window, the speed of a vehicle, the angle of the steering wheel. All of them are assotiated to a particular datatype, such as Integer, String, etc. Then actual values of those properties can have dynamic (i.e., data streams) or static behavior.\nProperties belong to some Entity that is of interest for our application. For example: Window, Vehicle, SteeringWheel, etc. So, an Entity can contain a collection of properties.\nThe principal idea here is to maintain a set of entities and their assotiated properties.\nIdea (2): Maintain a set of reusabel labels In some cases, there are entities that can have multiple instances. For example, A vehicle might not have one but multiple doors, windows, seats, batteries, tires, etc. Hence, it becomes useful to avoid repetition in the modeling by allowing the specification of reusable labels. A list of labels, such as InCabinZone, could contain the options FRONT_LEFT, and FRONT_RIGHT. These could be used directly to specify a particular Door, Windows, and Seat.\nIdea (3): Construct unique IDs To foster reusability and avoid naming conflicts, a rule set must be enforced. The minimum constraints must be:\nA namespace (ns) must be unique and future-proof. Within a namespace (ns), the name of an Entity must be unique. Within a namespace (ns), the name of an Enum must be unique. Within an Entity, the name of a Property must be unique. In the case of GraphQL schema language these constraints are supported. One can concatenate the elements to create International Resource Identifiers (IRIs)\nPREFIX ns: \u003cmynamespacehere\u003e ns:Door ns:Door.position ns:Door.isOpenThen, IRIs can be used when defining the schema in the application. For example, a json schema could look like:\n{ \"type\": \"object\", \"properties\": { \"door\": { \"implementedConcept\": \"ns:Door\", \"type\": \"object\", \"properties\": { \"position\": {\"type\": \"int\"}, \"isOpen\": {\"type\": \"boolean\"} }, } }, }Idea (4): Allow arbitrary hierarchies for different classification criteria As the Entity and Property sets grow over time, proper information classification becomes essential. The most tangible value of this organization is visible in any online shop. There, a faceted search is the default tool for filtering the available data with specific criteria. The same principle can be applied here.\nFor example, the Window entity can be classified by its physical position (Vehicle.Cabin.Door.Window), its principle of movement (MovablePart.UniDimensionalMove.Window), its material (Piece.GlassedPiece.Window), and by other criteria.\nThe Simple Knowledge Organization System (SKOS) is a well-established standard to achieve such classifications.\nIdea (5): Specify possible interactions The entity and property sets (of idea (1)) can be complemented with an specification of the set of possible operations on them (i.e., interactions or actions). For example:\nDomain Operation Seat Get the position of all seats. Seat Save a seat position to memory. Seat Control the heating mode of a seat. Climate Turn on/off the AC. Climate Set the temperature. Climate Get the fan speed per zone. Other ideas: TODO: Conversational tools, versioning, etc.\nExamples Refer to the examples folder.\nSpecial considerations The following cases require special treatments.\nDilemma: Property as field or as object type Here’s the markdown summarizing the three cases for your dilemma:\nCase 1: Scalar Field type Vehicle { speed: Int }Pros:\nSimple and concise representation. Easy to read and understand for straightforward use cases. Suitable for static properties that do not require additional metadata or complexity. Cons:\nLimited extensibility: Adding metadata (e.g., units like “km/h”) or additional attributes (e.g., timestamp) requires refactoring. Not future-proof: If the property evolves to include more details, significant schema changes are needed. Cannot represent complex relationships or metadata. Case 2: Dedicated Object Type type Vehicle { speed: VehicleSpeed } type VehicleSpeed { value: Int unit: String timestamp: String }Pros:\nHighly extensible: Allows adding metadata like unit or timestamp without breaking the schema. Better suited for complex properties: Can easily accommodate additional fields like ranges or error margins. Future-proof: Supports evolving requirements without major schema changes. Cons:\nMore verbose: Introduces additional layers of nesting, making the schema longer and more complex. Overhead for simple properties: Feels excessive for straightforward fields like speed. Harder to read and maintain for basic use cases. Case 3: Reusable Property Type type Vehicle { speed: IntProperty } type IntProperty { value: Int unit: String timestamp: String }Pros:\nReusability: The IntProperty type can be used across multiple fields (e.g., speed, weight, etc.), ensuring consistency and reducing duplication. Extensible: Like Case 2, it supports adding metadata or attributes without schema refactoring. Consistent: Standardizes the representation of similar properties across the schema. Future-proof: Accommodates evolving requirements while maintaining schema clarity. Cons:\nOverhead for simple properties: Adds complexity for fields that don’t require metadata. Generic naming: May feel less descriptive compared to dedicated types like VehicleSpeed. Potential for overgeneralization: If properties diverge significantly, the reusable type may become too generic. Recommendation Use Case 1 for simple, static properties that are unlikely to evolve or require metadata. Use Case 2 for properties that are unique and require specific metadata or complex structures. Use Case 3 for properties that share common metadata or structures across the schema, ensuring reusability and consistency. For vehicle-related information, Case 3 with a reusable type like IntProperty is often the best choice, as it balances extensibility, reusability, and clarity.\nEnums’ datatypes In GraphQL, enums are typically used to define a set of allowed values for a field. These values are usually represented as strings, such as [FIRST, SECOND, ...]. However, GraphQL enums are not limited to strings conceptually; they can represent any discrete set of values.\nIf your model defines “allowed” values as integers, like [0, 1, 2, ...], you can still use GraphQL enums to represent them. Internally, GraphQL will treat these enum values as strings in the schema, but you can map them to integers in your application logic.\nenum TheAllowedValues { ZERO ONE TWO }In your application, you can map ZERO to 0, ONE to 1, and so on. This approach allows you to enforce a fixed set of values while maintaining flexibility in how they are interpreted in your code.\nSpecial cross references GraphQL schema language excels in defining the structure of data models in a clear and understandable way. It provides robust elements such as types, fields within types, nested objects, and enumerations. These features allow for a well-organized and precise representation of data structures. However, it has limitations such as restricted cross-references, where linking fields to other fields directly is not possible.\nLet us assume our model has the concepts Window.position, AC.temperature, AC.isOn, Sunroof.position. In the GraphQL schema language, it is not possible to say that the Person.perceivedTemperature can be modified by acting on these properties.\ntype Window { position: Int } type AC { temperature: Float isOn: Boolean } type Sunroof { position: Int } type Person { perceivedTemperature: Int # I want to say that this property might be affected by acting on the others pTemp: PTem } type PTemp{ affectedByProp: Property value: String! } type Property { objectName: String! fieldName: String! }Option 1 - Instance data file An alternative would be to define the schema as usual, and then write another instance data file with concrete instance data that represents the connections. For example, that the perceived temperature is affected by Window.position, AC.temperature, AC.isOn, Sunroof.position.\nOption 2 - Enums with URIs However, the following is possible and supported by the language out of the box by using nested objects:\ntype Person { perceivedTemperature: PerceivedTemperature } type PerceivedTemperature { temperature: Int modifiableBy: [perceivedTemperatureModifiersEnum] } enum perceivedTemperatureModifiersEnum { ns:Window.position ns:AC.temperature ns:AC.isOn ns:Sunroof.position }Option 3 - using directives\n```graphql directive @affectedBy(object: String!, field: String!) on FIELD_DEFINITION type Person { perceivedTemperature: Int @affectedBy(object: \"Window\", field: \"position\") } type Window { position: Int }",
    "description": "Simplified Semantic Data Modeling (S2DM) - Approach Primer Table of Contents Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Vehicle Signal Specification has been an alternative but requires improvements Design principles Problem Requirements Goal Artifact Proposed solution approach General workflow Idea (1): Maintain Entity and Property sets Idea (2): Maintain a set of reusable labels Idea (3): Construct unique IDs Idea (4): Allow arbitrary hierarchies for different classification criteria Other ideas Examples Special considerations Special cross references Model versioning Background Why do we need such an approach?",
    "tags": [],
    "title": "Approach",
    "uri": "/s2dm/approach/index.html"
  },
  {
    "breadcrumb": "S2DM",
    "content": "Welcome to the guides section for Simplified Semantic Data Modeling (S2DM). Below are two key guides to help you get started:\nContributing Guide Learn how to contribute to the development of Simplified Semantic Data Modeling, including setting up your development environment, running tests, and maintaining code quality.\nModeling Guide Understand how to create and contribute to data specifications for specific domains using the Simplified Semantic Data Modeling approach.",
    "description": "Welcome to the guides section for Simplified Semantic Data Modeling (S2DM). Below are two key guides to help you get started:\nContributing Guide Learn how to contribute to the development of Simplified Semantic Data Modeling, including setting up your development environment, running tests, and maintaining code quality.\nModeling Guide Understand how to create and contribute to data specifications for specific domains using the Simplified Semantic Data Modeling approach.",
    "tags": [],
    "title": "Guides",
    "uri": "/s2dm/guides/index.html"
  },
  {
    "breadcrumb": "S2DM \u003e Guides",
    "content": "Contributing to Simplified Semantic Data Modeling NOTE: This document explains how to contribute to the data modeling approach itself. If you want to contribute to a certain data specification of a particular domain, then follow the Modeling Guide instead.\nDevelopment Environment S2DM uses uv for packaging and dependency management. To start developing with S2DM, install uv using the recommended method.\nOnce uv is installed, install the dependencies with the following command:\nuv syncIt will create a .venv in the root of the project.\nIf you want to have a shell in the virtual environment you can activate it with (for Linux/MacOS):\n. .venv/bin/activateThe package is linked in editable mode so you will not need to reinstall the package when changing something.\nAlternatively you can run things in the virtual environment by using a uv run prefix for commands, e.g.:\nuv run pytestThe following section commands assume you are in the virtual environment by either activating or prefixing commands with uv run!\nPre-Commit-Hooks Pre commit hooks can be setup with:\npre-commit installTests Run tests with the following command:\npytest --cov-report term-missing --cov=s2dm -vvNew code should ideally have tests and not break existing tests.\nType Checking Simplified Semantic Data Modeling uses type annotations throughout, and mypy to do the checking. Run the following to type check Simplified Semantic Data Modeling:\nmypy --ignore-missing-imports --no-implicit-optional --warn-unreachableCode Formatting Simplified Semantic Data Modeling uses ruff for code formatting. Since it is very fast it makes sense to setup your editor to format on save.\nUse ruff format to format all files in the currenct directory\nVersioning This tool is using semantic versioning. CHANGELOG.md should be updated on every source code change. A new version can be bumped with the support of bump-my-version, which is a dev dependency: # major,minor,patch bump-my-version bump minor ",
    "description": "Contributing to Simplified Semantic Data Modeling NOTE: This document explains how to contribute to the data modeling approach itself. If you want to contribute to a certain data specification of a particular domain, then follow the Modeling Guide instead.\nDevelopment Environment S2DM uses uv for packaging and dependency management. To start developing with S2DM, install uv using the recommended method.\nOnce uv is installed, install the dependencies with the following command:",
    "tags": [],
    "title": "Contributing Guide",
    "uri": "/s2dm/guides/contributing/index.html"
  },
  {
    "breadcrumb": "S2DM",
    "content": "Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains. Seat Capabilities: Specifying possible operations linked to seat-related objects or entities. Seat to VSS Mapping: Mapping modular seat specifications to the Vehicle Signal Specification (VSS). Specification History Registry: Tracking changes and maintaining a registry of specification history. If your use case is not covered by the presented examples, feel free to get in touch. If this approach suits your use case, we will add it here.",
    "description": "Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains. Seat Capabilities: Specifying possible operations linked to seat-related objects or entities. Seat to VSS Mapping: Mapping modular seat specifications to the Vehicle Signal Specification (VSS).",
    "tags": [],
    "title": "Examples",
    "uri": "/s2dm/examples/index.html"
  },
  {
    "breadcrumb": "S2DM",
    "content": " Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research. It also provides a solid legal framework if you choose to contribute to either the standards or the tools.\nWe will line out some answers to commonly asked questions, but keep in mind this page is informational. The legally binding clauses can be found in the license itself. If in doubt, consult your friendly neighborhood lawyer or IP department.\nCan I use VSS / VSS-tools in my commercial products Most definitely yes. You must inform your users that the product contains MPLed code and need to provide access to the source (e.g. by linking to this documentation or our Github repository).\nI modified VSS-tools, do I need to give away my source? If you use the code internally within your organisation (company), you have no obligations to do so. (see also Q5 here). If you distribute the modified vss-tools outside your organization (e.g. to your customers), you need to make the source code of the MPL-2.0 licensed parts available. However, the MPL has only a very weak copyleft effect. As a rule of thumb: You have no obligation to provide code in new files. You have the obligation to make code of changed existing MPLed files available under the clauses of the MPL-2.0, if you distribute them in source or compiled form outside your organisation ((see also Q9,10,11 here)).\nIn any case we do recommend you to consider sharing generally useful improvements with the community. Not only will you win karma points with the community and gain visibility as an innovation leader in the automotive industry, you will most likely also get more robust software as you will have more users and testers.\nI changed VSS or added custom signals to the standard catalog. Do I need to give them away? No. One important selling point of VSS is, that you can always extend the standard catalog with your own use case specific signals. There is no obligation to release any added signals or proprietary information to third parties.\nFrom an MPL-2.0 point of view the information of the previous question applies. To be extra sure, put any additions in separate files, and use the layering approach to modify the standard catalog. This community does not consider deleting elements from the standard catalog or adding VSS #include statements “modifications” in the sense of clause 1.10 of the MPL-2.0.\nAs with the tools, we do recommend you to consider sharing generally useful standard catalog improvements with the community.",
    "description": "Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research.",
    "tags": [],
    "title": "License",
    "uri": "/s2dm/license/index.html"
  },
  {
    "breadcrumb": "S2DM",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/s2dm/categories/index.html"
  },
  {
    "breadcrumb": "S2DM \u003e Guides",
    "content": "Modeling Guide NOTE: This document explains how to contribute to an specific model (new or existing). If you want to contribute to the data modeling approach itself, then see the Contributing Guide instead.\nTODO: Work in progress…\nBasic building blocks We re use following established artifacts:\nFor the specification of data structures and possible operations on that data, S2DM re uses the GraphQL Schema Definition Language (SDL). The full feature set is available in the official GraphQL specification. For the specification of multiple classification schemes, S2DM uses the Simple Knowledge Organization System (SKOS). To learn more about them, please consult the official documentation. Predefined elements Units A set of commonly used units is provided in the file /spec/unit_enums.graphql. For example:\nenum Velocity_Unit_Enum { KILOMETER_PER_HOUR METERS_PER_SECOND } TODO: Unify the units reference from the given sources.\nCOVESA VSS Units file. QUDT units Scalars Scalars in GraphQL are basically the datatypes to which a field resolves. GraphQL supports a few built-in scalars such as Int, Float, String, Boolean, and ID. It is possible to define custom ones. The file /spec/custom_scalars.graphql contains custom scalars that could be referenced in the model.\nCustom directives @instanceTag directive @instanceTag on OBJECT TODO: Add description and example\n@cardinality directive @cardinality(min: Int, max: Int) on FIELD_DEFINITION TODO: Add description and example\n@range directive @range(min: Float, max: Float) on FIELD_DEFINITION TODO: Add description and example\n@noDuplicates directive @noDuplicates on FIELD_DEFINITIONConsidering the following generic object:\ntype MyObject { field: \u003coutputType\u003e }By default, the GraphQL SDL let us express the following six combinations for output types in fields:\nCase Description outputType Nullable Singular Field A singular element that can also be null. NamedType Non-Nullable Singular Field A singular element that cannot be null. NamedType! Nullable List Field An array of elements. The array itself can be null. [NamedType] Non-Nullable List Field An array of elements. The array itself cannot be null. [NamedType]! Nullable List of Non-Nullable Elements An array of elements. The array itself can be null but the elements cannot. [NamedType!] Non-Nullable List of Non-Nullable Elements List and elements in the list cannot be null. [NamedType!]! Implicitly, lists here refer to an array of values that could be duplicated. In order to explicitly say that the intended content of the array should function as a set of unique values instead, the custom directive @noDuplicates is introduced.\ntype Person { nicknamesList: [String] # Array with possible duplicate values nicknamesSet: [String] @noDuplicates # Set of unique values }Common enumeration sets In some cases, it is practical to refer to a particular set of values that might fit to multiple use cases. For example, the zone inside the cabin of a car could be re used by the Door and the Window It could be modeled as:\ntype InCabinZone { row: InCabinRowEnum! side: InCabinSide! } enum InCabinRowEnum { FRONT REAR } enum InCabinSide { DRIVER_SIDE PASSENGER_SIDE }Then, it can be referenced from:\nWindow { instance: InCabinZone ... } Door { instance: InCabinZone ... }Such common enumeration sets are available in the file /spec/common_enums.graphql.\nModeling a new domain Identify the relevant object types (i.e., entities or classes). Examples: Vehicle, Person, etc. Specify an object type of each one (assuming it does not exist yet). Add fields to types to represent relationships. If the field resolves to a datatype, then assign an scalar. If the field connects to another object type, then assign it. Define the set of enum values. Add other metadata. Modeling an existing domain Extending an existing model Modifying an existing model Extending a type Deprecating elements It is possible to deprecate fields and enum values with the built-in directive @deprecated.\ntype Window { position: Int openness: Int @deprecated(reason: \"Use `position`.\") }To avoid breaking changes, GraphQL does not support the deprecation of types. To deprecate a complete type, simply deprecate all the fields or values inside.\ntype SomeDeprecatedObjectType { fieldOne: string @deprecated(reason: \"Use `MyNewType.fieldOne`.\") ... fieldN: string @deprecated(reason: \"Use `MyNewType.fieldN`.\") } type SomeDeprecatedEnum { ONE @deprecated(reason: \"Use `MyNewEnum`.\") ... TEN @deprecated(reason: \"Use `MyNewEnum`.\") }If you want to know more, click here to see the specification.\nModel versioning This simplified modeling approach suggests the use of the GraphQL schema language as a mechanism to model concepts as a graph in a simple manner. It does not mean that one must implement a GraphQL server (there might be some advantages to do so, though). It is purely about the language and the community tools that exist. According to the official documentation of the language, versioning the schema is considered a bad practice.\nWhile there’s nothing that prevents a GraphQL service from being versioned just like any other API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema…\n…GraphQL only returns the data that’s explicitly requested, so new capabilities can be added via new types or new fields on existing types without creating a breaking change. This has led to a common practice of always avoiding breaking changes and serving a versionless API.\nHowever, as the intention is to model a simple conceptual semantic model and not the full API itself, versioning is possible and special care must be given to the rule set.\nTODO: Work in progress…",
    "description": "Modeling Guide NOTE: This document explains how to contribute to an specific model (new or existing). If you want to contribute to the data modeling approach itself, then see the Contributing Guide instead.\nTODO: Work in progress…\nBasic building blocks We re use following established artifacts:\nFor the specification of data structures and possible operations on that data, S2DM re uses the GraphQL Schema Definition Language (SDL). The full feature set is available in the official GraphQL specification.",
    "tags": [],
    "title": "Modeling",
    "uri": "/s2dm/guides/modeling/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Simplified Semantic Data Modeling (S2DM) Welcome to the Simplified Semantic Data Modeling (S2DM) repository. S2DM is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\nDisclaimer: Bear in mind the word Simplified in the name. This approach aims to foster the adoption of (some) good data modeling practices. It does not intent to re invent, nor to replace long-standing standards, such as those of the Semantic Web. Hence, this approach does not incorporate advanced reasoning capabilities or the use of comprehensive ontologies typically associated with traditional semantic data modeling.\nS2DM adopts data modeling best practices and reuses the following elements:\nGraphQL Schema Definition Language (SDL). It provides a clear, human-readable syntax for defining data structures and relationships, making it easy for SMEs to understand and use without requiring deep technical expertise. SKOS. It offers a straightforward framework for creating and managing hierarchical classifications and relationships between concepts, facilitating the organization and retrieval of knowledge in a way that is both intuitive and semantically rich. To learn more about the background that has led to S2DM, as well as its design principles, please read the S2DM Approach Primer.",
    "description": "Simplified Semantic Data Modeling (S2DM) Welcome to the Simplified Semantic Data Modeling (S2DM) repository. S2DM is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\nDisclaimer: Bear in mind the word Simplified in the name.",
    "tags": [],
    "title": "S2DM",
    "uri": "/s2dm/index.html"
  },
  {
    "breadcrumb": "S2DM",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/s2dm/tags/index.html"
  }
]
